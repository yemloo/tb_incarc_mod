#-------------------------------------------
# Author: Yiran Liu
# Date Modified: 7.3.24
# Description: This contains the functions for the incarceration sub-model and 
# the main TB model, as well as a wrapper function for generating the functions
# for how prison entry & release rates change over time, and a function for
# computing annualized rates from TB model output
#-------------------------------------------
library(deSolve)

################################################################################
#           INCARCERATION SUB-MODEL
################################################################################
# Arguments include three interpolation functions for returning the value of 
# iR, iE, and r (entry and release rates) at any given timepoint. These functions
# are generated by a wrapper function further below
prison.model.with.growth <- function(t, x, params,
                                     iR_func, iE_func, r_func,
                                     quasi_2000=2000
){
  
  with(as.list(c(x, params)),{
    
    iR <- iR_func(t)
    iE <- iE_func(t)
    iN <- iE
    r <- r_func(t)
    
    muN <- mort_genpop_func(t-quasi_2000+2000) # mort_genpop_func has not yet been adjusted for quasi_2000 in main_script or calc_error_wrapper, need to do that here
    muE <- muN
    muR <- mortality_postrel_irr*muN
    muP <- mortality_incarc_irr*muN
    muS <- mortality_incarc_irr*muN
    
    if (pop_grow==T & !is.null(pop_grow_func) & t >= (quasi_2000-10)) { # pop_grow_func has not yet been adjusted for quasi_2000 in main_script or calc_error_wrapper, need to do that here
      births.deaths.ratio <- pop_grow_func(t-quasi_2000+2000)/100 / muN + 1
      # print('pop grow')
    } else {
      births.deaths.ratio <- 1
    }
    
    ##########################################################################################################
    #          MODEL EQUATIONS
    ##########################################################################################################
    
    # incarcerated first time
    dPdt <- iN*N - r*P - muP*P
    
    # incarcerated repeat
    dSdt<- iR*R + iE*E - r*S - muS*S
    
    # recent history of incarceration
    dRdt <- -iR*R + r*(P + S) - muR*R - a*R   # note: release rate is the same for first and subsequent incarcerations
    
    # distant history of incarceration
    dEdt <- a*R - iE*E - muE*E
    
    # never incarcerated
    dNdt <- births.deaths.ratio*(muP*P + muS*S + muR*R + muN*N + muE*E) - iN*N  - muN*N     
    
    # to keep track of total admissions 
    dIshadowdt <- iN*N + iR*R + iE*E                            
    
    # to keep track of re-admissions (recidivist entries)
    dIreshadowdt <- iR*R + iE*E
    
    # to keep track of total exits
    dEshadowdt <- r*(P+S)
    
    
    list(c(dPdt, dSdt, dRdt, dNdt, dEdt, dIshadowdt, dIreshadowdt, dEshadowdt))
  })
}

################################################################################
#           GENERATE FUNCTIONS FOR CHANGING INCARC RATES
################################################################################
### Args below govern changes in incarceration prevalence over time ###
# Changes in incarceration prevalence are achieved by linear changes in admissions rates and release rates over time
# For admissions rates, the rates of change in each period (k1, k2, k3) are calibrated;
# "start" and "end" arguments determine when each period of change starts and ends
# For release rates, the ratio of final/initial for each period (change.r.factor1 and change.r.factor2) is sampled from a distribution & fixed during calibration
# During COVID, admissions rates change temporarily (ie like a step function); they are multiplied by covidf
# For some countries, release rates change temporarily too, in the inverse direction (1/covidf)
# 2/9/24 EDIT: do not include state of emergency / El Sal future projections in this function
# 6/4/24 EDIT: all settings for start/end and factors are included in unvarying_incarc_params
get_incarc_functions <- function(incarc_params, # named vector, should include iR, iE, r, k1 (at minimum); may include k2, k3, covidf, SoEf
                                 unvarying_incarc_params
                                 ) {
  if (is.null(unvarying_incarc_params$change.r.factor1)){
    unvarying_incarc_params$change.r.factor1 <- 1
  }
  if (is.null(unvarying_incarc_params$change.r.factor2)){
    unvarying_incarc_params$change.r.factor2 <- 1
  }
  
  with(as.list(unvarying_incarc_params),{
    
    # print(change.r.factor1)
    # print(change.r.factor2)
    if (!'k2' %in% names(incarc_params)){
      change.incarc.start2 <- change.incarc.end1
      change.incarc.end2 <- change.incarc.end1
      incarc_params[['k2']] <- 0
    }
    if (!'k3' %in% names(incarc_params)){
      change.incarc.start3 <- change.incarc.end2
      change.incarc.end3 <- change.incarc.end2
      incarc_params[['k3']] <- 0
    }
    if (!'covidf' %in% names(incarc_params)){
      incarc_params[['covidf']] <- 1
    }
    if (!'k4' %in% names(incarc_params)){
      change.incarc.start4 <- ifelse(covid.end==Inf, change.incarc.end3, covid.end)
      change.incarc.end4 <- ifelse(covid.end==Inf, change.incarc.end3, covid.end)
      incarc_params[['k4']] <- 0
    }
    
    if (!'iE' %in% names(incarc_params) & 'iE:iR' %in% names(incarc_params)){
      incarc_params[['iE']] <- incarc_params[['iR']]*incarc_params[['iE:iR']]
    }
    if (is.null(change.r.factor1)){
      change.r.factor1 <- 1
    }
    if (is.null(change.r.factor2)){
      change.r.factor2 <- 1
    }
    
    #### First define the functions for entry rates over time ####
    iRiE.x <- c(change.incarc.start1, 
                change.incarc.end1, 
                change.incarc.start2, 
                change.incarc.end2, 
                change.incarc.start3,
                change.incarc.end3,
                covid.start, covid.start, covid.end, covid.end,
                change.incarc.start4,
                change.incarc.end4,
                intrvn.start, intrvn.end)
    if (all(iRiE.x == Inf)){ # if no change in entry rates over time
      iR_func <- function(x) incarc_params[['iR']]
      iE_func <- function(x) incarc_params[['iE']]
    } else {
      iRiE.omit <- which(iRiE.x == Inf)
      iRiE.use <- setdiff(1:length(iRiE.x), iRiE.omit)
      iR.y <- c(
        # 1a
        incarc_params[['iR']],
        # 1b
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']],
        # 2a
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']],
        # 2b
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']],
        # 3a
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']],
        # 3b
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # covid (pre)
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # covid
        (incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']])*incarc_params[['covidf']],
        # covid
        (incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']])*incarc_params[['covidf']],
        # covid (post)
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # 4a
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # 4b
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
          (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']],
        # intervention start
        incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
          (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']],
        # intervention end
        (incarc_params[['iR']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
           (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']])*intrvn.iR.factor)
      # print(iR.y)
      if (any(iR.y < 0)) { # make sure this never goes below zero
        fix <- which(iR.y < 0)
        iR.y[fix] <- 0
      }
      
      iE.y <- c(
        # 1a
        incarc_params[['iE']],
        # 1b
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']],
        # 2a
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']],
        # 2b
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']],
        # 3a
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']],
        # 3b
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # covid (pre)
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # covid
        (incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']])*incarc_params[['covidf']],
        # covid
        (incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']])*incarc_params[['covidf']],
        # covid (post)
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # 4a
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']],
        # 4b
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
          (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']],
        # intervention start
        incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
          (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
          (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
          (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']],
        # intervention end
        (incarc_params[['iE']]+(change.incarc.end1-change.incarc.start1)*incarc_params[['k1']] +
           (change.incarc.end2-change.incarc.start2)*incarc_params[['k2']] +
           (change.incarc.end3-change.incarc.start3)*incarc_params[['k3']] +
           (change.incarc.end4-change.incarc.start4)*incarc_params[['k4']])*intrvn.iE.factor)
      
      if (any(iE.y < 0)) { # make sure this never goes below zero
        fix <- which(iE.y < 0)
        iE.y[fix] <- 0
      }
      
      iR_func <- approxfun(x=iRiE.x[iRiE.use], 
                           y=iR.y[iRiE.use], 
                           ties='ordered',
                           rule=2)
      iE_func <- approxfun(x=iRiE.x[iRiE.use], 
                           y=iE.y[iRiE.use], 
                           ties='ordered',
                           rule=2)
    }
    
    #### now the functions for release rate over time ####
    r.x <- c(change.r.start1, change.r.end1,
             change.r.start2, change.r.end2,
             covid.start, covid.start, covid.end, covid.end,
             intrvn.start, intrvn.end)
    if (all(c(change.r.start1, change.r.start2, intrvn.start) == Inf) &
        (covid.start==Inf | covid.change.r==FALSE)) { # if no change in release rates over time
      r_func <- function(x) incarc_params[['r']]
    } else {
      r.omit <- which(r.x == Inf)
      if (covid.change.r == FALSE) { # if we don't want release rates to change during covid, add these to the list of indices to omit
        r.omit <- unique(c(r.omit, 5, 6, 7, 8))
      }
      r.use <- setdiff(1:length(r.x), r.omit)
      r.y <- c(incarc_params[['r']],
               incarc_params[['r']]*change.r.factor1,
               incarc_params[['r']]*change.r.factor1,
               incarc_params[['r']]*change.r.factor1*change.r.factor2,
               incarc_params[['r']]*change.r.factor1*change.r.factor2,
               incarc_params[['r']]*change.r.factor1*change.r.factor2/incarc_params[['covidf']],
               incarc_params[['r']]*change.r.factor1*change.r.factor2/incarc_params[['covidf']],
               incarc_params[['r']]*change.r.factor1*change.r.factor2,
               incarc_params[['r']]*change.r.factor1*change.r.factor2,
               incarc_params[['r']]*change.r.factor1*change.r.factor2*intrvn.r.factor)
      r_func <- approxfun(x=r.x[r.use],
                          y=r.y[r.use],
                          ties='ordered',
                          rule=2)
    }
    return(list(iR_func=iR_func, iE_func=iE_func, r_func=r_func))
  })
}

# special function for El Salvador: feed in above functions for pre-state of emergency;
# then use this to get incarc functions for whole period incl state of emergency & future projections
get_incarc_functions_elsal <- function(iE_func, iR_func, r_func, # pre-SoE
                                       SoEf, # iE_SoE = iE*SoEf
                                       SoEf_iR, # iR_SoE = iR*SoEf*SoEf_iR
                                       SoE_r, # directly sampled fed in
                                       SoEf2, # what entry rates decline to as a multiple of what they were before # 0.037 based on data: iE_3 (at state.emerg.start3) = iE*SoEf*SoE_decline_factor; iR_3 = iR*SoEf*SoE_decline_factor
                                       # intrvn='Continue SoE', # 'Continue SoE' if you want iE, iR, and r to remain as they are at state.emerg.start3; 'End SoE' if you want them to go to pre-SoE values or decarcerate further
                                       unvarying_incarc_params, # includes all intrvn settings
                                       step=0.05,
                                       quasi_2000=2000){
  
  with(as.list(unvarying_incarc_params),{
    # pre-SoE
    x_pre_SoE <- seq(quasi_2000-10, state.emerg.start-step, by=step)
    iE_pre_SoE <- iE_func(x_pre_SoE)
    iR_pre_SoE <- iR_func(x_pre_SoE)
    r_pre_SoE <- r_func(x_pre_SoE)
    # print(iE_pre_SoE)
    
    if (any(iE_pre_SoE <= 0)) { # make sure this never goes to or below zero
      fix <- which(iE_pre_SoE <= 0)
      iE_pre_SoE[fix] <- 0.0000001
    }
    # print(iE_pre_SoE)
    # SoE part 1: spike
    x_SoE_pt1 <- c(state.emerg.start, state.emerg.start2-step)
    iE_SoE_pt1 <- rep(tail(iE_pre_SoE, 1)*SoEf, 2)
    iR_SoE_pt1 <- rep(tail(iR_pre_SoE, 1)*SoEf*SoEf_iR, 2)
    r_SoE_pt1 <- rep(SoE_r, 2)
    
    # part 2: exponential decay in entry rates (log linear decline); r stays the same
    x_SoE_pt2 <- seq(state.emerg.start2, state.emerg.start3, by=step)
    iE_SoE_pt2 <- seq(log10(tail(iE_SoE_pt1, 1)*100000),
                      log10(tail(iE_pre_SoE, 1)*SoEf2*100000), 
                      length.out=length(x_SoE_pt2))
    iR_SoE_pt2 <- seq(log10(tail(iR_SoE_pt1, 1)*100000),
                      log10(tail(iR_pre_SoE, 1)*SoEf2*SoEf_iR*100000), 
                      length.out=length(x_SoE_pt2))
    
    # part 3: intervention period
    if (intrvn.start == Inf | intrvn == 'Continue SoE'){
      new_iE_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1, x_SoE_pt2),
                               y=c(iE_pre_SoE, iE_SoE_pt1, 10^iE_SoE_pt2/100000),
                               rule=2)
      new_iR_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1, x_SoE_pt2),
                               y=c(iR_pre_SoE, iR_SoE_pt1, 10^iR_SoE_pt2/100000),
                               rule=2)
      new_r_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1),
                              y=c(r_pre_SoE, r_SoE_pt1),
                              rule=2)
      return(list(iR_func=new_iR_func, iE_func=new_iE_func, r_func=new_r_func))
    } else if (intrvn == 'End SoE' & intrvn.start != Inf & intrvn.end != Inf) { # if intrvn == 'End SoE' - changes in entry rates are governed by intrvn.iE.factor and intrvn.iR.factor
      new_iE_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1, x_SoE_pt2, 
                                   intrvn.start, intrvn.end,
                                   intrvn.start2, intrvn.end2),
                               y=c(iE_pre_SoE, iE_SoE_pt1, 10^iE_SoE_pt2/100000, 
                                   10^tail(iE_SoE_pt2,1)/100000, tail(iE_pre_SoE,1)*intrvn.iE.factor,
                                   tail(iE_pre_SoE,1)*intrvn.iE.factor, tail(iE_pre_SoE,1)*intrvn.iE.factor2),
                               rule=2)
      new_iR_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1, x_SoE_pt2,
                                   intrvn.start, intrvn.end,
                                   intrvn.start2, intrvn.end2),
                               y=c(iR_pre_SoE, iR_SoE_pt1, 10^iR_SoE_pt2/100000,
                                   10^tail(iR_SoE_pt2,1)/100000, tail(iR_pre_SoE,1)*intrvn.iR.factor,
                                   tail(iR_pre_SoE,1)*intrvn.iR.factor, tail(iR_pre_SoE,1)*intrvn.iR.factor2),
                               rule=2)
      new_r_func <- approxfun(x=c(x_pre_SoE, x_SoE_pt1,
                                  intrvn.start, intrvn.end,
                                  intrvn.start2, intrvn.end2),
                              y=c(r_pre_SoE, r_SoE_pt1,
                                  tail(r_SoE_pt1,1), tail(r_pre_SoE,1)*intrvn.r.factor,
                                  tail(r_pre_SoE,1)*intrvn.r.factor, tail(r_pre_SoE,1)*intrvn.r.factor2),
                              rule=2)
      return(list(iR_func=new_iR_func, iE_func=new_iE_func, r_func=new_r_func))
    }
  })
}



################################################################################
#           TB MODEL
################################################################################
tb_model_for_calibration <- function(t, x, params, # as of 6/4/24, all settings are included in params vector
                                     ### Functions to change admissions and release rates ###
                                     iE_func, iR_func, r_func,
                                     quasi_2000=2000 # set the year for "2000" (use this when you are using earlier time steps for calibration efficiency)
                                     )
{
  with(as.list(c(x, params)),{
    
    #### This first section governs changing parameters over time ####
    q2 <- iR_func(t-quasi_2000+2000) # q2 is equivalent to iR
    q3 <- iE_func(t-quasi_2000+2000) # q3 is equivalent to iE
    q4 <- q3 # q4 is equivalent to iN
    r <- r_func(t-quasi_2000+2000)
    
    mu4 <- mort_genpop_func(t-quasi_2000+2000)
    mu3 <- mu4
    mu2 <- mortality_postrel_irr*mu4
    mu1 <- mortality_incarc_irr*mu4
    # print(t)
    
    if (pop_grow==T & !is.null(pop_grow_func) & t >= (quasi_2000-10)) {
      births.deaths.ratio <- pop_grow_func(t-quasi_2000+2000)/100 / mu4 + 1
      # print('pop grow')
    } else {
      births.deaths.ratio <- 1
    }
    
    if (t > change.d.start1){
      if (t <= change.d.end1){
        d2 <- d2+v*(t-change.d.start1)
        d3 <- d3+v*(t-change.d.start1)
        d4 <- d4+v*(t-change.d.start1)
      } else {
        d2 <- d2+v*(change.d.end1-change.d.start1)
        d3 <- d3+v*(change.d.end1-change.d.start1)
        d4 <- d4+v*(change.d.end1-change.d.start1)
      }
    }
    
    if (t > change.d.start2){
      if (t <= change.d.end2){
        d2 <- d2+v*change.d.2.factor*(t-change.d.start2)
        d3 <- d3+v*change.d.2.factor*(t-change.d.start2)
        d4 <- d4+v*change.d.2.factor*(t-change.d.start2)
      } else {
        d2 <- d2+v*change.d.2.factor*(change.d.end2-change.d.start2)
        d3 <- d3+v*change.d.2.factor*(change.d.end2-change.d.start2)
        d4 <- d4+v*change.d.2.factor*(change.d.end2-change.d.start2)
      }
    }
    
    if (t > change.beta.start1){
      if (t <= change.beta.end1){
        beta_cc <- beta_cc + z*(t-change.beta.start1)
      } else {
        beta_cc <- beta_cc + z*(change.beta.end1-change.beta.start1)
      }
    }
    
    if (t > change.beta.start2){
      if (t <= change.beta.end2){
        beta_cc <- beta_cc + z*change.beta.2.factor*(t-change.beta.start2)
      } else {
        beta_cc <- beta_cc + z*change.beta.2.factor*(change.beta.end2-change.beta.start2)
      }
    }
    
    if (t > change.beta.start3){
      if (t <= change.beta.end3){
        beta_cc <- beta_cc + z*change.beta.3.factor*(t-change.beta.start3)
      } else {
        beta_cc <- beta_cc + z*change.beta.3.factor*(change.beta.end3-change.beta.start3)
      }
    }
    
    
    if (t > change.prog.start1){
      if (t <= change.prog.end1){
        c2 <- c2 + j*(t-change.prog.start1)
        c3 <- c3 + j*(t-change.prog.start1)
        c4 <- c4 + j*(t-change.prog.start1)
      } else {
        c2 <- c2 + j*(change.prog.end1-change.prog.start1)
        c3 <- c3 + j*(change.prog.end1-change.prog.start1)
        c4 <- c4 + j*(change.prog.end1-change.prog.start1)
      }
    }
    
    if (t > change.prog.start2){
      if (t <= change.prog.end2){
        c2 <- c2 + j*change.prog.2.factor*(t-change.prog.start2)
        c3 <- c3 + j*change.prog.2.factor*(t-change.prog.start2)
        c4 <- c4 + j*change.prog.2.factor*(t-change.prog.start2)
      } else {
        c2 <- c2 + j*change.prog.2.factor*(change.prog.end2-change.prog.start2)
        c3 <- c3 + j*change.prog.2.factor*(change.prog.end2-change.prog.start2)
        c4 <- c4 + j*change.prog.2.factor*(change.prog.end2-change.prog.start2)
      }
    }
    
    if (t > change.betap.start1){
      if (change.betap.exp == TRUE){ # # this is if you want beta in prison to change exponentially rather than linearly, in the form of y = beta_P_baseline + exp(p*t)
        if (t <= change.betap.end1){
          beta_pp <- beta_pp+exp(p*(t-change.betap.start1))-1
        } else {
          beta_pp <- beta_pp+exp(p*(change.betap.end1-change.betap.start1))-1
        }
      } else {
        if (t <= change.betap.end1){
          beta_pp <- beta_pp+p*(t-change.betap.start1)
        } else {
          beta_pp <- beta_pp+p*(change.betap.end1-change.betap.start1)
        }
      }
    }
    
    if (t > change.betap.start2){
      if (change.betap.exp == TRUE){ 
        if (t <= change.betap.end2){
          if (change.betap.2.factor < 0) { # if decay
            beta_pp <- beta_pp*exp(p*change.betap.2.factor*(t-change.betap.start2))
          } else if (change.betap.2.factor >= 0) {
            beta_pp <- beta_pp+exp(p*change.betap.2.factor*(t-change.betap.start2))-1
          }
        } else {
          if (change.betap.2.factor < 0) { 
            beta_pp <- beta_pp*exp(p*change.betap.2.factor*(change.betap.end2-change.betap.start2))
          } else if (change.betap.2.factor >= 0) {
            beta_pp <- beta_pp+exp(p*change.betap.2.factor*(change.betap.end2-change.betap.start2))-1
          }
        }
      } else {
        if (t <= change.betap.end2){
          beta_pp <- beta_pp+p*change.betap.2.factor*(t-change.betap.start2)
        } else {
          beta_pp <- beta_pp+p*change.betap.2.factor*(change.betap.end2-change.betap.start2)
        }
      }
    }
    
    if (t > change.d1.start1){
      if (change.d1.exp == TRUE){
        if (t <= change.d1.end1){
          d1 <- d1+exp(v1*(t-change.d1.start1))-1
        } else if (change.d1.temp == FALSE) { # if not temporary, keep the change in diagnosis rates
          d1 <- d1+exp(v1*(change.d1.end1-change.d1.start1))-1
        } # if temporary and t > change.d1.end1, d1 is not changed (equals baseline value)
      } else {
        if (t <= change.d1.end1){
          d1 <- d1+v1*(t-change.d1.start1)
        } else if (change.d1.temp == FALSE) { # if not temporary, keep the change in diagnosis rates
          d1 <- d1+v1*(change.d1.end1-change.d1.start1)
        } # if temporary and t > change.d1.end1, d1 is not changed
      }
    }
    
    if (t > spike.d1.start1 & t <= spike.d1.end1) {
      d1 <- d1*spike.d1.factor
    }
    
    if (t > covid.change.d.start & t <= covid.change.d.end){
      d1 <- d1*covid.d.factor
      d2 <- d2*covid.d.factor
      d3 <- d3*covid.d.factor
      d4 <- d4*covid.d.factor
    }
    
    if (t > covid.change.beta.start & t <= covid.change.beta.end){
      beta_cc <- beta_cc*covid.change.beta.factor
    }
    
    # progression rate & diagnosis rate for recently released is a WEIGHTED average of the respective rates in prison and never incarc, with weights sampled from distribution
    d2 <- (d1*d1w) + (d4*(1-d1w))
    c2 <- (c1*c1w) + (c4*(1-c1w))
    
    ##########################################################################################################
    #          MODEL EQUATIONS
    ##########################################################################################################
    
    N1<-S1+E1+L1+I1+R1 # incarcerated ("p" in manuscript)
    N2<-S2+E2+L2+I2+R2 # recent history of incarceration ("r" in manuscript)
    N3<-S3+E3+L3+I3+R3 # distant history of incarceration ("d" in manuscript)
    N4<-S4+E4+L4+I4+R4 # never incarcerated ("n" in manuscript)
    N <- N1+N2+N3+N4
    
    ##### MIXING #####
    # beta_pp: within-prison mixing *CALIBRATED*
    # beta_pc: infectee in prison, infector in community (c; includes r, d, and n) *SAMPLED*
    # beta_cp: infectee in community, infector in prison *CALCULATED from beta_pc*
    # beta_cc: community mixing; beta_cc = beta_ff + beta_fn = beta_nn + beta_nf *CALIBRATED (as ratio to beta_pp)*
    # beta_ff: formerly incarcerated infectee (includes r and d), formerly incarcerated infector *CALCULATED from beta_cc*
    # beta_fn: formerly incarcerated infectee (includes r and d), never incarcerated infector *CALCULATED*
    # beta_nf: never incarcerated infectee, formerly incarcerated infector *CALCULATED*
    # beta_nn: formerly incarcerated infectee (includes r and d), formerly incarcerated infector *CALCULATED
    
    ## FOR ASSORTATIVE MIXING ##
    # This refers to mixing in the community among people with and without a history of incarceration. We lump 
    # recent history & distant history strata (N2 and N3) into one "formerly incarcerated" group, denoted with "f".
    # assrt.fctr refers to the relative amount of within-group mixing among formerly incarcerated people, compared
    # to what is expected under random/proportionate mixing. Under assortative mixing, we want to maintain the same 
    # total effective contact rate for each group as in proportionate mixing. Given symmetric between-group
    # mixing, we can then solve for the rest of the contact matrix (see manuscript appendix for details)
    beta_cp <- beta_pc*N1/(N2+N3+N4)
    
    beta_ff <- assrt.fctr*beta_cc*(N2+N3)/(N2+N3+N4)
    beta_fn <- beta_cc - beta_ff
    beta_nf <- (N2+N3)/N4 * beta_fn
    beta_nn <- beta_cc - beta_nf
    
    # incarcerated
    dS1dt <- -S1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) - # note: beta_pp is calibrated as contact rate conditional on prison to prison transmission, as this is easier to interpret
      r*S1 - mu1*S1 + q2*S2 + q3*S3 + q4*S4
    dE1dt <- S1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) + 
      alpha*L1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) + 
      alpha*R1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) - 
      b*E1 - c1*E1 - r*E1 - mu1*E1 + q2*E2 + q3*E3 + q4*E4
    dL1dt <- b*E1 - e*L1 - 
      alpha*L1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) - 
      r*L1 - mu1*L1 + q2*L2 + q3*L3 + q4*L4
    dI1dt <- c1*E1 + e*L1 - d1*I1 - sc*I1 + gamma*R1 - r*I1 - mu1*I1 - muI*I1 + q2*I2 + q3*I3 + q4*I4
    dR1dt <- d1*I1 + sc*I1 - 
      alpha*R1*(beta_pp*(I1/N1) + beta_pc*(I2+I3+I4)/(N2+N3+N4)) -
      gamma*R1 - r*R1 - mu1*R1 + q2*R2 + q3*R3 + q4*R4
    
    # recently released
    dS2dt <- -S2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) +
      r*S1 - mu2*S2 - q2*S2 - a*S2 # a is the rate at which recently released individuals transition to formerly incarcerated
    dE2dt <- S2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) +
      alpha*L2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) + # reinfection from late latent
      alpha*R2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) - 
      b*E2 - c2*E2 + r*E1 - mu2*E2 - q2*E2 - a*E2
    dL2dt <- b*E2 - e*L2 - alpha*L2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) + 
      r*L1 - mu2*L2 - q2*L2 - a*L2
    dI2dt <- c2*E2 + e*L2 - d2*I2 - sc*I2 + gamma*R2 + r*I1 - mu2*I2 - muI*I2 - q2*I2 - a*I2
    dR2dt <- d2*I2 + sc*I2 - alpha*R2*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) - 
      gamma*R2 + r*R1 - mu2*R2 - q2*R2 - a*R2
    
    # distant history of incarc
    dS3dt <- -S3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) -
      mu3*S3 - q3*S3 + a*S2 # a is the rate at which recently released individuals transition to formerly incarcerated
    dE3dt <- S3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) +
      alpha*L3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) + # reinfection from late latent
      alpha*R3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) - 
      b*E3 - c3*E3 - mu3*E3 - q3*E3 + a*E2
    dL3dt <- b*E3 - e*L3 - alpha*L3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) -
      mu3*L3 - q3*L3 + a*L2
    dI3dt <- c3*E3 + e*L3 - d3*I3 - sc*I3 + gamma*R3 - mu3*I3 - muI*I3 - q3*I3 + a*I2
    dR3dt <- d3*I3 + sc*I3 - alpha*R3*(beta_cp*I1/N1 + beta_ff*(I2+I3)/(N2+N3) + beta_fn*I4/N4) - 
      gamma*R3 - mu3*R3 - q3*R3 + a*R2
    
    # never incarc (the funky things at the beginning determine S/E/L ratio of overall births since these people are being born around 15yo)
    dS4dt <- births.deaths.ratio*((1-(1-exp((-beta_cp*I1/N1 - beta_nf*(I2+I3)/(N2+N3) - beta_nn*I4/N4)*15)))*
                (mu1*N1 + mu2*N2 + mu3*N3 + mu4*N4 + muI*(I1+I2+I3+I4))) - 
      S4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) - mu4*S4 - q4*S4
    dE4dt <- births.deaths.ratio*((prop_E*(1-exp((-beta_cp*I1/N1 - beta_nf*(I2+I3)/(N2+N3) - beta_nn*I4/N4)*15)))*
                (mu1*N1 + mu2*N2 + mu3*N3 + mu4*N4 + muI*(I1+I2+I3+I4))) +
      S4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) + 
      alpha*L4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) + 
      alpha*R4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) - 
      b*E4 - c4*E4 - mu4*E4 - q4*E4
    dL4dt <- births.deaths.ratio*(((1-prop_E)*(1-exp((-beta_cp*I1/N1 - beta_nf*(I2+I3)/(N2+N3) - beta_nn*I4/N4)*15)))*
                (mu1*N1 + mu2*N2 + mu3*N3 + mu4*N4 + muI*(I1+I2+I3+I4))) + 
      b*E4 - e*L4 - 
      alpha*L4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) - 
      mu4*L4 - q4*L4
    dI4dt <- c4*E4 + e*L4 - d4*I4 - sc*I4 + gamma*R4 - mu4*I4 - muI*I4 - q4*I4
    dR4dt <- d4*I4 + sc*I4 - 
      alpha*R4*(beta_cp*I1/N1 + beta_nf*(I2+I3)/(N2+N3) + beta_nn*I4/N4) - 
      gamma*R4 - mu4*R4 - q4*R4
    
    dI1shadowdt <- c1*E1 + e*L1 + gamma*R1 # keep track of incident TB cases
    dI2shadowdt <- c2*E2 + e*L2 + gamma*R2
    dI3shadowdt <- c3*E3 + e*L3 + gamma*R3
    dI4shadowdt <- c4*E4 + e*L4 + gamma*R4
    
    
    dD1shadowdt <- d1*I1 # keep track of detected cases (ie, notifications)
    dD2shadowdt <- d2*I2
    dD3shadowdt <- d3*I3
    dD4shadowdt <- d4*I4
    
    dmuI1shadowdt <- muI*I1 # keep track of TB deaths
    dmuI2shadowdt <- muI*I2
    dmuI3shadowdt <- muI*I3
    dmuI4shadowdt <- muI*I4
    
    
    list(c(dS1dt, dE1dt, dL1dt, dI1dt, dR1dt, 
           dS2dt, dE2dt, dL2dt, dI2dt, dR2dt, 
           dS3dt, dE3dt, dL3dt, dI3dt, dR3dt,
           dS4dt, dE4dt, dL4dt, dI4dt, dR4dt,
           dI1shadowdt, dI2shadowdt, dI3shadowdt, dI4shadowdt,
           dD1shadowdt, dD2shadowdt, dD3shadowdt, dD4shadowdt, 
           dmuI1shadowdt, dmuI2shadowdt, dmuI3shadowdt, dmuI4shadowdt
    ))
  })
}

#### function to compute annualized rates of incident cases, notifications, and deaths from output matrix ####
get_annualized_rates <- function(output_matrix, horiz.start=1000, horiz.end=1010, by.increment=1){
  output_melt <- melt(data.table(output_matrix), id.vars = 'time')[grepl('shadow',variable) |
                                                                     grepl('N',variable)]
  output_melt[grepl(1, variable), pop := 'Prison']
  output_melt[grepl(2, variable), pop := 'Post-Release']
  output_melt[grepl(3, variable), pop := 'Formerly Incarc']
  output_melt[grepl(4, variable), pop := 'Never Incarc']
  output_melt$variable <- gsub('1|2|3|4', '', output_melt$variable)
  
  N_only <- output_melt[variable == 'N',c('time','pop','value'),with=F]
  N_only_combined <- N_only[,.(N.total=sum(value)), by=c('time')]
  N_only <- merge(N_only, N_only_combined, by='time')
  setnames(N_only, 'value','N')
  output_melt <- merge(output_melt[variable != 'N'], 
                       N_only, 
                       by=c('time','pop'),
                       allow.cartesian = T)
  
  final_dt <- data.table()
  for (t in seq(horiz.start, horiz.end-by.increment, by=by.increment)){
    shadow_totals <- output_melt[,.(rate_per100k = (.SD[time == (t+by.increment), value] - .SD[time == t, value]) / .SD[time == t, N] * 100000 / by.increment,
                                    total = (.SD[time == (t+by.increment), value] - .SD[time == t, value]) / .SD[time == t, N.total] * 100000 / by.increment), 
                                 by=c('pop','variable')]
    shadow_totals$variable <- gsub('shadow', '', shadow_totals$variable)
    combined <- shadow_totals[,.(rate_per100k = sum(total), total = sum(total)), by=c('variable')]
    combined$pop <- 'Combined'
    shadow_totals <- rbind(shadow_totals, combined)
    shadow_totals$time <- t
    final_dt <- rbind(final_dt, shadow_totals, fill=TRUE)
  }
  final_dt
}
